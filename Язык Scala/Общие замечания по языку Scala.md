Тезисы:
- В Scala все -- это _объекты с методами_.
- Все операторы являются методами, например, `1 + 2` вызывает `1.+(2)`. Оператором может быть любой метод.
- В Scala различают `val`- (что-то вроде финальных переменных в Java) и `var`-переменные (нефинальные переменные в Java). Важно: `val`-переменная -- это ==НЕ константа==, потому как даже после инициализации она остается переменной [[Литература#^311838]]<c. 125>.
- Рекомендуется использовать финальные `val`-переменные вместо обычных `var`-переменных, работать с неизменяемыми объектами и писать в функциональном стиле, но в том же время программы, написанные в императивном стиле, не считаются чем-то неприемлемым. 
- _Массивы_ относятся к объектам _изменяемого_ типа данных [[Литература#^311838]]<c. 68>. Массивы всегда изменяемы[[Литература#^311838]]<c. 72>. Емкость массивы после создания его экземпляра изменить невозможно, но можно изменять его элементы. Если очень грубо, то их можно рассматривать (концептуально, а не с точки зрения алгоритмической реализации) как списки фиксированной емкости.
- _Списки_ в Scala всегда _неизменяемые_ [[Литература#^311838]]<c. 68>.
- _Кортежи_ неизменяемые гетерогенные коллекции [[Литература#^311838]]<c. 71>. 
- Синглтон-объекты / объекты-компаньоны -- хранилище статических методов.
- Обычно синглтон-объекты используются либо как _объекты-компаньоны_ (то есть привязываются к классу и выступают в роли хранилища вспомогательных элементов), либо как _автономные объекты_ для оформления точки входа в приложение Scala.
- К закрытым (используется ключевое слово `private`) элементам класса (полям, методам и пр.) доступ возможен только из тела класса или объекта [[Литература#^311838]]<c. 243>.
- К защищенному элементу (`protected`) класса доступ возможен только из-под его подклассов. 
- Закрытые элементы (`private`) родительского класса ==не наследуются подклассом== [[Литература#^311838]]<c. 190>.
- В Scala ==нет статических элементов==, вместо них может быть _объект-компаньон_, содержащий элементы, существующие в единственном экземпляре.
- Все аргументы в списке параметров case-класса (это что-то вроде дата-классов или именованных кортежей в Python) автоматически получают префикс `val`, то есть сохраняются в качестве _полей_ [[Литература#^311838]]<c. 262>.

Scala -- это язык общего назначения, предоставляющий поддержку объектно-ориентированного и функционального программирования со строгой системой статических типов (то есть Scala является _статически типизированным языком_).

Исходный код Scala компилируется в байт-код Java, поэтому полученный в итоге выполяемый код работает на виртуальной машине JVM. Scala обеспечивает языковое взаимодействие с Java, поэтому библиотеки, написанные на обоих языках, могут использоваться непосредственно в коде Scala и Java.

В настоящее время Spark v3 поддерживает Scala v2.12 и v2.13 [[Литература#^008892]]<c. 549>.

В Scala _функция_ по смыслу является _объектом_.  Типы функций представляют собой классы. Все операции в Scala -- вызовы методов.

В Scala _трейты_ (типажи) подобны интерфейсам в Java, но могут содержать также реализации методов и даже поля. Объекты создаются путем смешивания состава, при котором к элементам класса добавляются элементы ряда трейтов. Таким образом, различные аспекты классов могут быть инкапсулированы в различных трейтах. Это выглядит как множественное наследование, но отличается в конкретных деталях. В отличие от класса, трейт может добавить в родительский класс новые функциональные возможности, что придает трейтам более высокую степень подключаемости по сравнению с классами. В частности, благодаря этому удается избежать возникновения присущих множественному наследованию классических проблем "ромбовидного" наследования, которые возникают, когда один и тот же класс наследуется по нескольким различным путям [[Литература#^311838]]<c. 41>. 

Хотя Scala является чистым объектно-ориентированным языком, его можно назвать и полноценным функциональным.

Функциональное программирование базируется на двух основных идеях [[Литература#^311838]]<c. 41>:
- функции выступают как _значения первого класса_; в функциональных языках функция является значением, имеющим такой же статус, как целое число или строка. Функции можно передавать в качестве аргументов другим функциям, возвращать как результат из других функций или сохранять в переменных. Функцию можно также задавать внутри другой функции точно так же, как это делается при определении внутри функции целочисленного значения. И функции можно определять, не присваивая им имен.
- операции программы должны _преобразовывать входные значения в выходные_, ==а не изменять данные по месту==; еще один способ утверждения этой идеи функционального программирования заключается в том, что у методов не должно быть побочных эффектов. Они должны обмениваться данными со своей средой только путем получения аргументов и возвращения результатов. 

Функциональные языки заставляют применять неизменяемые структуры данных и референциально прозрачные методы. Scala дает возможность выбора. При желании можно писать программы в имеративном стиле -- так называется программирование с изменяемыми данными и побочными эффектами. Но если нужно, то в большинстве случаев Scala позволяет с легкостью избежать применения императивных конструкций благодаря существованию хороших функциональных альтернатив.
