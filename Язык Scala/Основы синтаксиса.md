### Определение переменных

В Scala есть две разновидности переменных:
- `val`-переменные,
- `var`-переменные.

`val`-переменные аналогичны _финальным переменным_ в Java. После инициализации `val`-переменная уже никогда не может быть повторно присвоена. В отличие от нее, `var`-переменная аналогична нефинальной переменной в Java. В течение своего жизненного цикла `var`-переменная может быть присвоена повторно.
```scala
val msg = "Hello, world!"
```

Другими словами, `val`-переменной можно присвоить значение только один раз, а `var`-переменной -- несколько раз.

Эта инструкция вводит в употребление переменную `msg` в качестве имени для строки `"Hello, world!"`. Типом `msg` является `java.lang.String`, поскольку строки в Scala реализуются Java-классом `String`. Здесь нет ни `java.lang.String`, ни `String`. Этот пример демонстрирует _логический вывод типа_, то есть возможность Scala определять неуказанные типы. Когда интерпретатор (или компилятор) Scala хочет выполнить вывод типа, зачастую лучше всего будет позволить ему сделать это, не засоряя код ненужной явной аннотацией типа.
### Определение функции

Компилятор Scala (и интерпретатор, но с этого момента будет упоминаться только компилятор) ==не выводит типы параметров функции==. Пример функции
```scala
def max(x: Int, y: Int): Int = {
  if (x > y) x else y
}
```

В Python этот пример выглядел бы так
```python
def max_(x: int, y: int) -> int:
  return x if x > y else y
```

Пример функции, которая не принимает параметров и не возвращает результат (то есть это процедура)
```scala
// def greet(): Unit
def greet() = println("Hello, world!")
```

В Python было бы так
```python
def greet() -> None:
    print("Hello, world")
```

Тип результата `Unit` показывает, что функция ничего не возвращает. Тип `Unit` в Scala подобен типу `void` в Си или Java. Таким образом, методы с типом результата `Unit` выполняются только для того, чтобы проявились их побочные эффекты.

Аргументы командной строки, указанные для сценариев Scala, можно получить из Scala-массива по имени `args`. В Scala индексация элементов массива начинается с нуля и обращение к элементу выполняется указанием индекса _в круглых скобках_. То есть первым элементом в Scala-массиве по имени `steps` будет `steps(0)`, а не `steps[0]` как в Java или Python.

В Scala в простейшем случая можно обойтись и без объектов-оберток и явных точек входа (как в Python)
```scala
// helloargs.scala
println("Hello, " + args(0) + "!")
```
Здесь `args` читает аргументы командной строки, а `args(0)` -- это первый аргумент, который будет передан сценарию, например
```bash
$ scala helloargs.scala Scala  # Hello, Scala!
```

В Python пришлось бы использовать `sys.argv`, модуль `argparse` или что-то подобное.

Сценарии Scala можно запускать и без явного обращения к утилите `scala`. Для того в начале сценария нужно набрать `#!...!#`
```scala
#!bash
exec scala "$0" "$@"
!#
println("Hello, " + args(0) + "!")
```

В Python можно просто указать `#!python`, а затем сделать сценарий исполняемым с помощью `chmod +x`
```python
#!python
print("Hello, Python!")
```
### Параметризация массивов типами

Пример массива строк
```scala
// Лучше сразу создавать массив с элементами!!!
// То есть
// val greetings = Array("Java", "Scala", "Python")
val greetins = new Array[String](3)
greetings(0) = "Java"  // первый элемент массива
greetings(1) = "Scala" // второй элемент массива
greeintgs(2) = "Python" // ...
greetings.foreach(println)
```

Как уже упоминалось, доступ к массивам в Scala осуществляется за счет помещения индекса в круглые, а не квадратные скобки, как в Java (или в Python).

В элементы типа `Array[String]` можно вносить изменения, следовательно, сам _массив является изменяемым_! То есть в Scala массив ведет себя также как и массив в NumPy
```scala
scala> val arr = Array[Double](3.14, 5.5, 10.2)
scala> arr(1) = 8.6  // то же, что и arr.apply(1)
scala> arr  // val res49: Array[Double] = Array(3.14, 8.6, 10.2)
```

А в Python 
```python
>>> import numpy as np
>>> arr = np.array([3.14, 5.5, 10.2])
>>> arr[1] = 8.6
>>> arr  # Out[27]: array([ 3.14,  8.6 , 10.2 ])
```

Массивы в Scala, как и в случае с любыми другими классами, являются просто экземплярами классов. При использовании круглых скобок, окружающих одно или несколько значений переменной, Scala преобразует код в вызов метода по имени `.apply()` применительно к этой переменной. Следовательно, код `arr(0)` преобразуется в код `arr.apply(0)`. Получается, что элемент массива в Scala является просто вызовом обычного метода. Этот принцип не ограничивается массивами: любое применение объекта в отношении каких-либо аргументов в круглых скобках будет преобразовано в вызов метода `.apply()` [[Литература#^311838]]<c. 66>. То есть это не особый случай, а общее правило.

По аналогии с этим, когда присваивание выполняется в отношении переменной, к которой применены круглые скобки с одним или несколькими аргументами внутри, компилятор выполнит преобразование в вызов метода `.update()`, получающего не только аргументы в круглых скобках, но и объект, расположенный справа от знака равенства.
```scala
scala> greeting(0) = "Hello"  // то же, что и greeting.update(0, "Hello")
```

Все в Scala -- от массивов до выражений -- рассматривается _как объекты с методами_ . Не нужно запоминать особые случаи [[Литература#^311838]]<c. 67>.

В Scala имеется более лаконичный способ создания и инициализации массивов, который, как правило, вы и будете использовать.
```scala
val numNames = Array("zero", "one", "two")
```
Здесь вызывается фабричный метод `.apply()`, создающий и возвращающий новый массив. Этот метод `.apply()` получает переменное количество аргументов и определяется в _объекте-компаньоне_ (объекте-спутнике) `Array`. Это можно интерпретировать как вызов статического метода `.apply()` в отношении класса `Array`, то есть
```scala
Array.apply("zero", "one", "two")
```
### Использование списков

Изменить длину массива после создания его экземпляра невозможно, но вы можете менять значение его элементов. Таким образом, _массивы_ относятся к _изменяемым объектам_ [[Литература#^311838]]<c. 68>.

Наблюдение: Если очень грубо, то _массивы_ в Scala (как и NumPy-массивы в Python)  (концептуально, а не с точки зрения алгоритмической реализации!) можно рассматривать как _списки фиксированной емкости_.

Для _неизменяемой последовательности_ объектов с _общим типом_ можно воспользоваться списком, определяемым Scala-классом `List`. Списки Scala всегда _неизменяемые_. Для объединения списков имеется метод `:::`.
```scala
val lst = List(10, 20, 30)
```

Наблюдение: Выходит, что в Scala _списки_ это что-то вроде массивов или кортежей (но при условии что в кортеж собираются объекты одного типа) в Python. То есть _списки в Scala_ это _неизменяемые гомогенные коллекции_.
```python
>>> arr = np.array([10, 20, 30])  
>>> arr.dtype  # dtype('int64')
>>> tpl1: t.Tuple[int, ...] = (10, 20, 30)
>>> tpl2: t.Tuple[str, ...] = ("Python", "Scala")
```

В классе `List` предлагается _операция добавления_, которая записывается как `:+`, но очень редко используется, поскольку время, которая она тратит на добавление к списку, увеличивается линейно с размером списка, а на добавление в начало списка с помощью метода `::` (то же, что и `+:`) всегда затрачивается одно и то же время. Если нужно добиться эффективности при создании списка путем дополнения элементами, можно воспользоваться _изменяемым буферизованным списком_ `ListBuffer`, предлагающим операцию добавления, а затем, завершив добавление, вызвать метод `.toList` и преобразовать его в обычный список [[Литература#^311838]]<c. 70>.

NB! В выражении `1 :: twoThree` метод `::` является методом его _правого операнда_, то есть списка `twoThree`. Простое мнемоническое правило: если метод используется в виде оператора, например `a * b`, то он вызывается в отношении _левого операнда_, как в выражении `a.*(b)`, если только имя метода не заканчивается двоеточием. А если оно заканчивается двоеточием, то метод вызывается в отношении правого операнда. Поэтому в выражении `1 :: twoThree` метод `::` вызывается как `thoThree.::(1)` [[Литература#^311838]]<c. 69>.

Некоторые методы класса `List`:
- `List()` или `Nil`: создает пустой список. В Scala так: `val lst = Nil` или так `val lst = List()`. В Python так: `lst = []`,
- `List("Scala", "Python")` создает новый список типа `List[String]` с двумя значениями. В Python так: `lst = ["Scala", "Python"]`,
- `List("a", "b") ::: List("c", "d")` объединяет два списка и возвращает новый список типа `List[String]`. В Python так: `["a", "b"] + ["c", "d"]`,
- `thrill(2)` возвращает элемент с индексом 2. В Python так: `thrill[2]`,
- `thrill.count(_.length == 4)` подсчитывает количество строковых элементов в списке `thrill` длины 4. В Python так: `sum(1 for elem in thrill if len(elem) == 4)` 
- `thrill.drop(2)`: возвращает список `thrill` _без его первых двух элементов_. В Python нужно сделать срез: `thrill[2:]`,
- `thrill.dropRight(2)`  возвращает список `thrill` без самых правых двух элементов. В Python нужно сделать срез: `thrill[:-2]`.
- `thrill.exists(_ == "until")` определяет в списке `thrill` строкового элемента, имеющего значение `"until"` (возвращает `true`). В Python так: `any(True for s in thrill if s == "until")`,
- `thrill.filter(_.length == 4)` возвращает список всех элементов длины 4. В Python так: `[elem for elem in thrill if len(elem) == 4]`,
- `thrill.forall(_.endsWith("l"))` показывает, оканчиваются ли все элементы в списке `thrill` символом `"l"` (возвращает `true`). В Python так: `all(elme.endswith("a") for elem in thrill)`,
- `thrill.mkString(",")` создает строку с элементами списка. В Python так: `",".join(thrill)`.
### Использование кортежей

Еще одним полезным объектом-контейнером является _кортеж_. Кортежи, как и списки, в Scala нельзя изменять, но, в отличие от списков, в кортежах могут содержаться _различные типы элементов_. Кортежи находят применение, например при возвращении из метода сразу нескольких объектов. Все делается просто: для создания экземпляра нового кортежа, содержащего объекты, нужно лишь заключить объекты в круглые скобки, отделив их друг от друга запятыми. Подсчет элементов начинается с единицы.
```scala
scala> val pair = (99, "Luftballons") // val pair: (Int, String)
scala> pair._1  // 99
scala> pair._2 // Luftballons
```
Наблюдение: Кортежи в Scala представляют собой неизменяемые гетерогенные коллекции и этим очень похожи на кортежи в Python, но для случая, когда кортеж используется в качестве гетерогенной записи, возвращаемой, например, из функции.

Реальный тип кортежа зависит от количества содержащихся в нем элементов и от типов этих элементов. Следовательно, типом кортежа `(99, "Luftballons")` является `Tuple2[Int, String]`, а типом кортежа `('u', 'r', "the", 1, 4, "me")` -- `Tuple6[Char, Char, String, Int, Int, String]`.

В то время как в Java мы реализуем интерфейсы, в Scala мы расширяем, или подмешиваем _трейты_.
### Использование наборов (множеств) и отображений

Массивы всегда изменяемы, а списки всегда неизменяемы. Scala также предоставляет изменяемые и неизменяемые альтернативы для наборов (множеств) и отображений, но использует для обеих версий одни и те же простые имена.

Для того чтобы получить замороженное множество, то есть множество, которое не может принимать новые элементы, то следует привязать экземпляр `Set` `val`-переменной
```scala
scala> val langs = Set("Java", "Scala")
scala> langs += "Python"  // error: value += is not a member of scala.collection.immutable.Set[String]
```

Но если экземпляр `Set` привязать `var`-переменной, то можно будет добавить новый элемент
```scala
scala> var langs = Set("Java", "Scala")
scala> langs += "Python"
scala> langs  // val res5: scala.collection.immutable.Set[String] = Set(Java, Scala, Python)
```

Как для изменяемых, так и для неизменяемых множеств метод `+` создает и возвращает _новое множество_ с добавленным элементом.

Если требуется _изменяемое множество_, то следует
```scala
import scala.collection.mutable

val movieSet = mutable.Set("Hitch", "Poltergeist")
movieSet += "Shrek"
```

Наблюдение: Для того чтобы реализовать изменяемое множество можно либо связать экземпляр класса `Set` с `var`-переменной, либо явно использовать изменяемое множество `mutable.Set`.

Еще одним полезным классом коллекций в Scala является отображение -- `Map`. Как и для наборов, Scala предоставляет изменяемые и неизменяемые версии `Map` с использованием иерархии классов.
```scala
import scala.collection.mutable

val treasureMap = mutable.Map[Int, String]()
treasureMap += (1 -> "Go to island")
treasureMap += (2 -> "Find big X onn ground.")
```

Здесь при создании экземпляра пустого ассоциативного массива приходится явно указывать тип, так как без этого указания компилятор не сможет логически вывести тип параметров.
### Классы и объекты

Поля -- переменные экземпляра класса, поскольку каждый экземпляр получает собственный набор переменных.
```scala
class ChecksumAcc {
  var sum = 0  // переменная экземпляра класса
}

val acc1 = new ChecksumAcc // Первый экземпляр класса
val acc2 = new ChecksumAcc // Второй экземпляр класса

acc1.sum = 10
acc2.sum = 20
```

В Python было бы так
```python
class ChecksumAcc:
    def __init__(self, sum_: int = 0) -> None:
        self.sum_ = sum_  # открытый атрибут экземпляра класса

acc1 = ChecksumAcc(10)
acc2 = ChecksumAcc(20)
```
Все переменные экземпляра класса составляют образ объекта в памяти. То, что здесь показано, свидетельствует не только о том, что есть две переменные `sum`, но и о том, что изменение одной из них никак не отражается на другой.

В этом примере следует также отметить, что у вас есть возможность изменить объект, на который ссылается `acc`, даже несмотря на то, что `acc` относится к `val`-переменным. Но с учетом того, что `acc` является `val`-переменной, а не `var`-переменной, вы не можете присвоить ей какой-нибудь другой объект.

Переменная `acc1` всегда будет ссылаться на тот же объект `ChecksumAcc`, с использованием которого вы ее инициализировали, но поля, содержащиеся внутри этого объекта, могут со временем измениться.

Один из важных способов обеспечения надежности объекта является гарантия того, что состояние этого объекта (то есть значения его переменных экземпляра) остается корректным в течение всего его жизненного цикла. Первым шагом к предотвращению непосредственного стороннего доступа к полям является создание _закрытых_ полей.

Поскольку _доступ к закрытым полям_ можно получить _только методами, определенными в том же самом классе_ [[Литература#^311838]]<c. 122>, весь код, который может обновить состояние, будет локализован в классе. Чтобы объявить поле закрытым, перед ним ставится модификатор доступа `private` .
```scala
class CheckSumAcc {
  private var sum = 0  // закрытый атрибут экземпляра класса
}
```

==Теперь к атрибуту `sum` не удастся получить доступ через экземпляр класса, но можно из кода, определенного внутри тела самого класса==. В Python было бы так
```python
class CheckSumAcc:
    def __init__(self, sum_: int = 0) -> None:
        self._sum = sum_  # псевдозакрытый атрибут экземпляра класса
```

В Scala элементы класса делают открытыми, если нет явного указания какого-либо модификатора доступа. Иначе говоря, там, где в Java ставится модификатор `public`, в Scala мы обходимся простым замалчиванием. Открытый (`public`) доступ в Scala является уровнем доступа по умолчанию.

В конце метода можно не использовать `return`. В отсутствие явно указанной инструкции `return` метод в Scala возвращает  последнее вычисленное им значение. При написании методов рекомендуется применять стиль, исключающий явное и особенно многократное использование инструкции `return` [[Литература#^311838]]<c. 86>.

Метод, который выполняется только для получения его побочного эффекта, называется _процедурой_ [[Литература#^311838]]<c. 86>. 

В программе на языке Scala точку с запятой в конце инструкции обычно можно не ставить.
### Синглтон-объекты `object`

==В классах Scala не могут содержаться _статические элементы_==. _Вместо этого в Scala имеются синглтон-объекты_. Определение синглтон-объекта выглядит так же, как и определение класса, за исключением того, что вместо ключевого слова `class` используется ключевое слово `object`.

Когда синглтон-объект использует общее с классом имя, то для класса он называется _объектом-компаньоном_ (или объектом-спутником). И класс, и его объект-компаньон нужно определять в одном и том же файле. _Класс и его объект-компаньон могут обращаться к закрытым элементам друг друга_ [[Литература#^311838]]<c. 89>.
```scala
// CheckSumAcc.scala
import scala.collection.mutable

class CheckSumAcc {
  ...
}
// Объект-компаньон класса CheckSumAcc
object CheckSumAcc {
  private val cache = mutable.Map.empty[String, Int]

  def calculate(s: String): Int = 
    if (cache.contains(s)) cache(s)
    else {
      val acc = new CheckSumAcc
      for (c <- s)
        acc.add(c.toByte) 
      val cs = acc.checksum()
      cache += (s -> cs)
      cs
    }
}
```

Одно из отличий классов от синглтон-объектов состоит в том, что ==синглтон-объекты не могут принимать параметры, а классы -- могут==. Поскольку создать экземпляр синглтон-объекта с помощью ключевого слова `new` нельзя, передать ему параметры не представляется возможным. Каждый синглтон-объект реализуется как экземпляр _синтетического класса_, ссылка на который находится в статической переменной. В частности, синглтон-объекты инициализируются при первом обращении к нему какого-либо кода [[Литература#^311838]]<c. 90>.

Синглтон-объект, который _не имеет общего имени с классом-компаньоном_, называется _автономным объектом_. Такие объекты можно применять для решения многих задач, включая сбор в одно целое родственных вспомогательных методов (хранилище вспомогательных элементов) или определение _точки входа в приложение Scala_ [[Литература]]<c. 91>. 
### Приложение на языке Scala

Для запуска программы на Scala нужно представить имя автономного синглтон-объекта с методом `main`, получающим один параметр с типом `Array[Stringn]` и использующим тип результата `Unit`. _Точкой входа_ в приложение может стать _любой автономный объект с методом_ `main` , имеющим надлежащую сигнатуру [[Литература#^311838]]<c. 91>.
```scala
// Summer.scala
import CheckSumAcc.calculate

// Автономный объект как точка входа
object Summer {
  def main(args: Array[String]): Unit = {
    for (arg <- args)
      println(arg + ": " + calculate(arg))
  }
}
```

В Scala файл с расширением `.scala` можно называть как угодно независимо от того, какие классы Scala или код в них содержатся. Но, как правило, когда речь идет не о сценариях, рекомендуется придерживаться стиля, при котором файлы называются по именам классов, которые в них содержаться, как это делается в Java, чтобы программистам было легче искать классы по именам их файлов. 

Еще удобно пользоваться трейтом `App`
```scala
import CheckSumAcc.calculate

object FallWinterSpringSummer extends App {
  for (season <- List("fall", "winter", "spring"))
    println(season + ": " + calculate(season))
}
```

Вместо написания метода `main()` между фигурными скобками синглтон-объекта следует набрать код, который вы поместили бы непосредственно в метод `main()`. Обратиться к аргументам командной строки можно через массив строковых элементов по имени `args`. Вот и все. Это приложение можно откомпилировать и запустить точно так же, как и любое другое.
###  Рекурсивные ссылки

Ключевое слово `this` (в Python используется ключевое слово `self`) позволяет ссылаться на экземпляра класса, в отношении которого был вызван выполняемый в данный момент метод, или, если оно использовалось в конструкторе, -- на создаваемый экземпляр класса.

Пример
```scala
class Person(
  name: String,  // параметр класса
  age: Int  // параметр класса
) {
  def getSummary(): String = {
    s"Summary: name -> ${this.name}, age -> ${this.age}"
  }
}

val leorFinkelberg = new Person("Leor Finkelberg", 37)
leorFinkelberg.getSummary  // Summary: name -> Leor Finkelberg, age -> 37
```
Здесь метод `.getSummary` вызывается без круглых скобок, потому как этот метод-аксессор. 

На Python это выглядело бы так
```python
class Person:
    def __init__(self, name; str, age: int) -> None:
        self._name = name  # атрибут экземпляра класса
        self._age = age  # атрибут экземпляра класса

    @property
    def name(self) -> str:  # доступен только для ЧТЕНИЯ
        return self._name

    @property
    def age(self) -> int:  # доступен только для ЧТЕНИЯ
        return self._age

    def get_summary() -> str:
        return f"Summary: name -> {self._name}, age -> {self._age}"

leor_finkelberg = Person("Leor Finkelberg", 37)
leor_finkelberg.get_summary()  # Summary: name -> Leor Finkelberg, age -> 37
```

Впрочем в Python можно было бы построить класс и на именованном кортеже
```python
import typing as t

class Person(t.NamedTuple):
    name: str  # атрибут экземпляра класса только для ЧТЕНИЯ
    age: int  # атрибут экземпляра класса только для ЧТЕНИЯ

	# метод экземпляра класса
    def get_summary(self) -> str:
        return f"Summary: name -> {self._name}, age -> {self._age}"
```

В Scala слово "константа" не означает просто `val`-переменную. Даже при том что `val`-переменная остается неизменной после инициализации, она не перестает быть переменной. Например, параметры методы метода относятся к `val`-переменным, но при каждом вызове метода в этих `val`-переменных содержаться разные значения. Константа обладает более выраженным постоянством.

В отличие от Java, Python, Си и пр. по соглашению в Scala у имени константы в верхнем регистре должна быть только первая буква. То есть, если в Java константа называется `X_OFFSET`, то в Scala она должна называться `XOffset`.

Из Scala исключены инструкции `break` и `continue` [[Литература#^311838]]<c. 145>.
### Область видимости переменных

У объявлений переменных в программах Scala имеется _область видимости_, определяющая, где конкретно может использоваться имя переменной. Самым распространенным примером определения области видимости является применение фигурных скобок, которые, как правило, вводят новую область видимости, и все, что определяется внутри этих скобок, теряет видимость после закрывающей скобки [[Литература#^311838]]<c. 148>.
### Функции первого класса

В Scala имеются _функции первого класса_. Вы может не только определить их и вызывать для выполнения, но и записать в виде безымянных _литералов_, после чего передать их в качестве _значений_. 

_Функциональный литерал_ (лямбда-функция; анонимная функция) компилируется в класс, который при создании экземпляра на этапе выполнения программы становится _функциональным значением_. Таким образом, разница между функциональными литералами и значениями состоит в том, что функциональные литералы существуют в исходном коде, а функциональные значения существуют в виде объектов на этапе выполнения программы. Эта разница во многом похожа на разницу между классами (исходным кодом) и объектами (создаваемыми на этапе выполнения программы).

Пример
```scala
scala> val someNumbers = List(-11, -10, -5, 0, 5, 10)
scala> someNumbers.filter((x: Int) => x > 0)
// Но можно записать короче с помощью заместителя
scala> someNumbers.filter(_ > 0)
```
Чтобы сделать _функциональный литерал_ (лямбда-функция) короче, можно воспользоваться знаком подчеркивания в качестве _заместителя_ для одного или нескольких параметров при условии, что каждый параметр появляется внутри функционального литерала только один раз.

Несколько знаков подчеркивания означают наличие нескольких параметров, а не многократное использование одного и того же параметра. Первый знак подчеркивания представляет первый параметр, второй знак подчеркивания -- второй параметр, третий знак подчеркивания -- третий параметр и т.д.
### Замыкания

Пример
```scala
(x: Int) => x + more
```

С точки зрения данной функции `more` является _свободной переменной_, поскольку в самом функциональном литерале значение ей не присваивается. В отличие от нее, переменная `x` является _связанной_, так как в контексте функции у нее есть значение: она определена как единственный параметр функции, имеющий тип `Int` [[Литература]]<c. 163>.

Функциональное значение, создаваемое на этапе выполнения программы из этого функционального литерала, называется _замыканием_. Такое название появилось из-за замыкания функционального литерала путем _захвата привязок его свободных переменных_.
### Специальные формы вызова функций

Можно передавать список аргументов переменной длины. Чтобы обозначить повторяющийся параметр, поставьте после типа параметра знак звездочки `*`
```scala
// Чтобы позиционные аргументы собирались в массив, обязательно нужно поставить * после типа формального параметра!!!
scala> def echo(args: String*): Unit =
         // args: Array[String], то есть массив строк
         for (arg <- args) println(arg)
```
Определенная таким образом функция может быть вызвана с нулем и большим количеством аргументов типа `String`.

Внутри функции типом повторяющегося параметра является `Array`, то есть массив элементов объявленного типа параметра. Таким образом, типом переменной `args` внутри функции `echo`, которая объявлена как тип `String*`, фактически является `Array[String]`.

Несмотря на это, если у вас имеется массив подходящего типа, то при попытке передать его в качестве повторяющегося параметра будет получена ошибка компиляции. Чтобы добиться успеха, нужно после аргумента в виде массива поставить `_*`, то есть
```scala
scala> val arr = Array("Python", "Scala")
scala> echo(arr: _*)  // распаковка массива `arr`
```

В Python было бы так
```python
def echo(*args: str) -> None:
    args: t.Tuple[str, ...]  # то есть кортеж строк

    for arg in args:
        print(arg)

echo("Python", "Scala")
arr = ("Python", "Scala")
echo(*arr)  # распаковка кортежа `arr`
```

Именованные аргументы позволяют передавать аргументы функции в произвольном порядке. Синтаксис просто предусматривает указание перед каждым аргументом имени параметр и знак равенства.
```scala
scala> speed(distance = 100, time = 10)
scala> speed(time = 10, distance = 100)
```

Scala позволяет указать для параметров функции значения по умолчанию. Аргумент для такого параметра может быть произвольно опущен из вызова функции, в таком случае соответствующий аргумент будет заполнен значением по умолчанию.
```scala
scala> def printTime(out: java.io.PrintStream = Console.out) = 
         out.println("time = " + System.currentTimeMillis())
```

Функция с двумя параметрами, у которых есть значения по умолчанию
```scala
def printTime2(
  out: java.io.PrintStream = Console.out,
  divisor: Int = 1
) = out.println("time = " + System.currentTiemMillis() / divisor)
```
### Концевая рекурсия

Функции, которые в качестве последнего действия вызывают самих себя, называются _функциями с концевой рекурсией_. Компилятор Scala _обнаруживает концевую рекурсию и заменяет ее переходом к началу функции_ после обновления параметров функции новыми значениями. Избегать использования рекурсивных алгоритмов для решения ваших задач не стоит. Зачастую рекурсивное решение выглядит более элегантно и лаконично, чем решение на основе цикла. Если в решении используется концевая рекурсия, то _расплачиваться за нее издержками производительности на этапе выполнения программы не придется_ [[Литература#^311838]]<c. 169>. 
### Управляющие абтсракции

Функции высшего порядка -- это функции, которые могут принимать другие функции в качестве параметров.
```scala
def filesMatcing(
  query: String,
  mathcer: (String, String) => Boolean  // здесь ожидается функция
) = {
  for (file <- filesHere; if matcher(file.getName, query))
    yield file
}
```

Здесь параметр `matcher` имеет функциональный тип: `(String, String) => Boolean`, то есть ожидается функция, которая принимает два строковых значения и возвращает булево.

Теперь можно упростить три поисковых метода, заставив их вызывать вспомогательный метод, передавая в него соответствующую функцию
```scala
def filesEnding(query: String) = filesMatching(query, _.ensWith(_))

def filesContaing(query: String) = filesMatching(query, _.contains(_))

def filesRegex(query: String) = filesMatching(query, _.matches(_))
```
Функциональные литералы, показанные в этом примере, используют синтаксис заместителя. Функциональный литерал `_.endsWith(_)`, используемый в методе `filesEnding`, означает то же самое, что и следующий код:
```scala
(fileName: String, query: String) => fileName.endsWith(query)
```
В данном случае, так как каждый из параметров используется только один раз, можно воспользоваться синтаксисом заместителей -- `_.endsWith(_)`. Первый знак подчеркивания станет заместителем для первого параметра -- имени файла, а второй -- заместителем для второго параметра -- строки запроса.

Вывести список файлов можно так
```scala
val filesHere = (new java.io.File(".")).listFiles

for (file <- filesHere) 
  println(file)
```
Ну или сразу создать экземпляр на позиции итерируемого объекта
```scala
for (file <- (new java.io.File(".")).listFiles)
  println(file)
```
Или так -- без явного цикла `for`
```scala
(new java.io.File(".")).listFiles.foreach(println)
```

То есть конструкция `(new java.io.File(".")).listFiles` возвращает массив файловых объектов. В Python можно было бы сделать так 
```python
import pathlib2

for file in pathlib2.Path(".").glob("*"):
    print(file.name)
```

Использование замыканий для сокращения повторяющихся фрагментов кода
```scala
object FileMatcher {
  private def filesHere = (new java.io.File(".")).listFiles

  private def filesMatching(matcher: String => Boolean) = 
    for (file <- filesHere; if matcher(file.getName))
      yield file
}

// `_` - связанная переменная, а `query` - свободная переменая
def filesEnding(query: String) = filesMatching(_.endsWith(query))

def filesContaining(query: String) = filesMatching(_.contains(query))
```
Замыкания помогают сократить повторяемость кода. Функциональные литералы, использованные в предыдущем примере, такие как `_.endsWith(_)` и `_.contains(_)`, на этапе выполнения программы становятся экземпялрами функциональных значений, не являющимися замыканиями, поскольку они не захватывают никаких свободных переменных. К примеру, обе переменные, использованные в выражении `_.endsWith(_)`, представлены в виде знаков подчеркивания, следовательно, они берутся из аргументов функции. Таким образом, в `_.endsWith(_)` ==применяются не свободные, а две связанные переменные==. 

В отличие от этого, в функциональном литерале `_.endsWith(query)` содержатся одна _связанная переменная_, а именно аргумент, представленный знаком подчеркивания (`_`), и одна свободная переменная -- `query` .
### Карринг

Каррированная функция применяется не к одному, а к нескольким спискам аргументов.
```scala
def tripletSum(x: Int) = (y: Int, z: Int) => x + y + z
```
Вызов этой функции может выглядеть так
```scala
tripletSum(10)(20, 30)
```

В Python было бы так
```scala
from functools import partial

def triplet_sum(x: int, y: int, z: int) -> int:
    return x + y + z

partial(triplet_sum, 10)(y=20, z=30)
```
### Case-классы

Пример case-класса
```scala
case class Var(name: String) extends Expr
```
Преимущества case-классов [[Литература#^311838]]<c. 262>:
- Первое синтаксическое удобство заключается в том, что к классу добавляется фабричный метод с именем этого класса, поэтому для создания экземпляра можно не использовать ключевое слово `new`
```scala
val v = Var("x")
```
- Второе синтаксическое удобство заключается в том, что _все аргументы в списке параметров case-класса автоматически получают префикс_ `val`, то есть сохраняются в качестве _полей_, то есть
```scala
// Параметры case-класса неявно рассматриваются как `val`
case class Person(
  name: String,  // публичное поле, а не параметр
  age: Int  // публичное поле, а не параметр
)
```
Если бы мы писали обычный класс, то пришлось бы указывать префикс `val`, чтобы закрытые параметры первичного конструктора стали публичными полями. А при создании экземпляра класса нужно было бы указывать ключевое слово `new`
```scala
class Person(
  val name: String,
  val age: Int
)

val leor = new Person("Leor Finkelberg", 37)  // используется `new`!

// Распаковать можно так
val Person(name, age) = leor
```
Наблюдение: case-классы в Scala это что-то вроде дата-классов (или именованных кортежей) в Python
```python
import typing as t
from dataclasses import dataclass

class Person1(t.NamedTuple):
     name: str
     age: int
     email: str

@dataclass(frozen=True)
class Person2:
    name: str
    age: int
    email: str
```
- Третье удобство состоит в том, что компилятор добавляет к вашему классу естественную реализацию методов `toString`, `hashCode` и `equals`.
- И наконец, для создания измененных копий компилятор добавляет к вашему классу метод `copy`. Этот метод пригодится для разработки нового экземпляра класса, аналогично другому экземпляру, за исключением того, что он будет отличатся один или двумя атрибутами.

Пример _шаблона-последовательности_ [[Литература#^311838]]<c. 269>
```scala
def check(subject: Any) = {
  subject match {
    case List(0, elems @ _*) => println(s"Elems: ${elems}")
    case _ => println("Oops")
  }
}

check(List(0, 1, 2, 3))  // Elems: List(1, 2, 3)
```
Здесь `_*` совпадает с произвольной последовательностью. А `@` позволяет привязать элементы, попавшие в `_*` к переменной.
### Экстракторы

Экстракторы в Scala представляют собой объект, у которого в качестве одного из элементов имеется метод `.unapply`.

Пример
```scala
object Email {
  // Метод вставки (необязательный): это инъекция
  def apply(user: String, domain: String) = user + "@" + domain

  // Метод извлечения (обязательный!): это эстракция
  def unapply(str: String): Option[(String, String)] = {
    val parts: Array[String] = str.split("@")
    if (parts.length == 2) Some(parts(0), parts(1)) else None
  }
}
```
Метод `.unapply` является именно тем элементом, который превращает `EMail` в экстрактор [[Литература#^311838]]<c. 533>. Если `.apply` получает две строки и формирует из них строку адреса электронной почты, то `.unapply` получает адрес электронной почты и потенциально возвращает две строки: `user` и `domain`, извлеченные из этого адреса. Но `.unapply` также должен справляться со случаями, когда заданная строка не является адресом электронной почты. Именно поэтому `.unapply` в отношении пары строк возвращает `Option`-тип.

Теперь каждый раз, когда поиск по шаблону сталкивается с шаблоном, ссылающимся на объект-экстрактор, он вызывает в отношении выражения выбора принадлежащий экстрактору метод `.unapply`. Например, выполнение кода
```scala
selectorString match { case EMail(user, domain) => ...}
```
приведет к вызову
```scala
EMail.unapply(selectorString)
```
Вызов `EMail.unapply` приведет к возвращению либо `None`, либо `Some(u, d)`, и для последних значений `u` будет пользовательской частью адреса, а `d` -- его доменной частью. В случае возвращения `Some(u, d)` поиск по шаблону пройдет удачно и его переменные будут привязаны к элементам возвращаемого значения.

Применять можно так
```scala
scala> Email("leor.finkelberg", "yandex.ru")  // leor.finkelberg@yandex.ru
scala> val Email(name, domain) = "leor.finkelberg@yandex.ru" // .unapply
```

В объекте может быть только метод экстракции без соответствующей инъекции. Сам объект называется экстрактором независимо от того, содержит он метод `.apply` или нет.
#### Шаблоны без переменных или с одной переменной

В Scala нет кортежей с одним элементом. Чтобы возвращался только один элемент шаблона, метод `.unapply` просто заключает в оболочку `Some()` сам элемент.
```scala
object Twice {
  def apply(s: String): String = s + s

  def unapply(s: String): Option[String] = {
    val length = s.length / 2
    val half = s.substring(0, length) // это как бы [:length] в Python
    // А здесь s.substing(length) это как бы [length:]
    if (half == s.substring(length)) Some(half) else None
  }
}
```

Шаблон экстрактора может вообще не привязывает никаких переменных. В таком случае соответствующий метод `.unapply` возвращает булево значение `true` при успешном поиске и `false` -- при сбое.
```scala
object UpperCase {
  def unapply(s: String): Boolean = s.toUpperCase == s
}
```
#### Экстракторы переменного количества аргументов

Все предыдущие примеры экстракции для адресов электронной почты возвращали фиксированное количество элементов значений. Иногда такой подход недостаточно гибок. 

Для поиска соответствия переменному количеству аргументов используется метод `.unapplySeq`
```scala
object Domain {
  // Метод вставки (необязательный)
  def apply(parts: String*): String = parts.reverse.mkString(".")

  // Метод извлечения (обязательный)
  def unapplySeq(whole: String): Option[Seq[String]] =
    Some(whole.split("\\.").reverse.toSeq)
}
```

Тип результата `.unapplySeq` должен соответствовать `Option[Seq[T]]`, где тип элемента `T` может быть произвольным. `Seq` является весьма важным классом в иерархии коллекций Scala. Это общий родительский класс для нескольких классов, дающих описания различных видов коллекций: `List`-коллекций, `Array`-коллекций, `WrappedString`-коллекций и некоторых других.

Экстрактор `Domain` можно использовать для получения более детализированной информации о строках адресов электронной почты. Например, для поиска адресов электронной почты с именем `tom` в каком-либо домене `.com`, можно воспользоваться следующей функцией
```scala
def isTomInDotCom(s: String): Boolean = s match {
  case EMail("tom", Domain("com", _*)) => true
  case _ => false
}

scala> isTomInDotCom("tom@sun.com") // true
scala> isTomInDotCom("peter@sun.com") // false
```

Можно также наряду с переменной частью получить в качестве возвращаемого значения `.unapplySeq` ряд фиксированных элементов. Это выражается в возвращении всех элементов в кортеже, где переменная часть, как обычно, будет последней
```scala
object ExpandedEMail {
  def unapplySeq(email: String): Option[(String, String)] = {
    val parts = email.split("@") 
    if (parts.length == 2)
      Some(parts(0), parts(1).split("\\.").reverse.toSeq)
    else
      None
  }
}
```

Использование
```scala
val ExpandedEMail(name, topdom, subdoms @ _*) = "tom@support.epfl.ch"
name: String = tom
topdom: String = ch
subdoms: Seq[String] = WrapperArray(epfl, support)
```

Независимость представлений дает экстракторам существенные преимущества над case-классами. Но и у case-классов имеются некоторые преимущества над экстракторами [[Литература#^311838]]<c. 541>:
- Во-первых, case-классы намного проще настраивать и определять и для них требуется меньше кода.
- Во-вторых, они зачастую приводят к более эффективной организации поиска по шаблону, чем экстракторы, поскольку _компилятор Scala может оптимизировать шаблоны, применяемые к case-классам, намного лучше шаблонов, применяемых к экстракторам_. Дело в том, что механизмы case-классов являются фиксированными, а методы `.unapply` или `.unapplySeq` в экстракторе способны практически на все. В-третьих, если ваши case-классы являются наследниками запечатанных базовых классов, компилятор Scala проверит ваши поиски по шаблону на исчерпаемость и станет возражать, если какие-либо комбинации возможных значений не были охвачены шаблоном. ==Для экстракторов любые проверки на исчерпаемость недоступны==.

Разумеется, бывают ситуации, когда с самого начала понятно, что структура шаблонов не соответствует представлению типов ваших данных. В таком случае единственным доступным вариантом останутся экстракторы.