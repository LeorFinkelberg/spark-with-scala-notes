### Массивы

Массивы позволяют хранить последовательность элементов и оперативно обращаться к элементу, находящемуся в произвольной позиции, с целью либо получения этого элемента, либо его обновления, для чего используется индекс, отсчитываемый от нуля.
```scala
scala> val arr = new Array[Int](3)  // Array(0, 0, 0)
scala> arr(1) = 10
scala> arr  // Array(0, 10, 0)
```
### Буферный список

Класс `List` предоставляет _быстрый доступ к голове и хвосту списка_, ==но не к его концу==. Таким образом, если нужно построить список с добавлением элементов к концу, следует рассмотреть возможность построения списка в обратном порядке путем добавления элементов спереди. Затем, когда это будет сделано, нужно вызвать метод `.reverse`, чтобы получить элементы в нужном порядке.

Другим вариантом, позволяющим избежать реверсирования, является использование объекта `ListBuffer`. Это содержащийся в пакете `scala.collection.mutable` _изменяемый_ объект, который может помочь более эффективно строить списки, когда нужно _добавлять элементы к их концу_. `ListBuffer` обеспечивает _постоянное время выполнения операций добавления элементов как к концу, так и к началу списка_. К концу списка элемент добавляется с помощью оператора `+=`, а к началу -- с помощью оператора `+=:`. Когда построение будет завершено, можно получить список типа `List` путем вызова  в отношении `ListBuffer` метода `.toList`.
```scala
scala> import scala.collection.mutable.ListBuffer
scala> val buf = new ListBuffer[Int]
scala> buf += 1
scala> buf += 2
scala> 3 +=: buf  // добавит элемент в начало
scala> buf.+=:(4) // добавит элемент в начало
scala> buf.toList
```
### Буферный массив

Объект `ArrayBuffer` похож на массив, за исключением того, что в дополнение ко всему _здесь предоставляется возможность добавления и удаления элементов в начале и в конце последовательности_. То есть другими словами по сравнению с обычным массивом емкость буферного массива можно изменять, добавляя новые элементы в начало или в конец последовательности.  
```scala
import scala.collection.mutable.ArrayBuffer
```

При создании `ArrayBuffer` нужно задать параметр типа, а длину указывать необязательно. По мере надобности `ArrayBuffer` автоматически установит выделяемое пространство памяти
```scala
scala> val buf = new ArrayBuffer[Int]()
scala> buf += 12 // добавить в конец
scala> buf += 15 // добавить в конец
scala> buf(0)  // 12
scala> 0 +=: buf  // добавить в начало
scala> buf.+=:(-1)  // добавить в начало
```
### Наборы (множества) и отображения

По умолчанию, когда в коде применяется `Set` или `Map`, вы получаете _неизменяемый_ объект. Если нужен неизменяемый вариант, следует воспользоваться явно указанным импортированием. К неизменяемым вариантам Scala предоставляет самый простой доступ -- в качестве небольшого поощрения за то, что предпочтение отдается им, а не их изменяемым аналогам.

Если нужно воспользоваться как изменяемым, так и неизменяемыми наборами или отображениями, то одним из подходов является импортирование имен пакетов, в которых содержаться изменяемые варианты
```scala
scala> import scala.collection.mutable
scala> val mutSet = mutable.Set(1, 2, 3)
```

Создать пустое изменяемое множество можно так
```scala
mutable.Set.empty[String]
```

Если импортировать пакет с именем `mutable`, можно создать пустое изменяемое отображение
```scala
mutable.Map.empty[String, Int] // тип для ключа и значения
```

Для небольших наборов и отображений неизменяемые версии занимают намного меньше места, чем изменяемые. С учетом того что многие коллекции имеют небольшой размер, перевод их в разряд неизменяемых может принести существенную экономию пространства памяти и выгодные условия для повышения производительности системы [[Литература#^311838]]<c. 329>.

Если объявить переменную как `var`-переменную, а не как `val`-переменную, то даже в том случае, если левый операнд относится к объектам неизменяемого типа данных, коллекцию удастся обновить с помощью составного оператора `+=` (при том, что неизменяемые множества и отображения не поддерживают этот метод). Сначала создастся новая коллекция, а затем переменной `people` присваивается новое значение для ссылки на новую коллекцию
```scala
scala> var people = Set("Python", "Scala")  // VAR-переменная
scala> people += "Java"
```

Та же идея применима не только к методу `+=`, но и к любому другому методу, заканчивающемуся знаком `=`.