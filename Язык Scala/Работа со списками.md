Возможно, самым важным типом последовательности, о котором следует знать, является класс `List` -- _неизменяемый связанный список_. Списки поддерживают _быстрое добавление и удаление элементов в начале списка_, ==но не обеспечивают возможности получить быстрый доступ к произвольным индексам==, поскольку реализация вынуждена выполнять последовательный обход всех элементов списка, то есть элемент ищется за $O(n)$.

Операции `drop` и `take` обобщают `tail` и `init` в том смысле, что возвращают произвольные префиксы или суффиксы списка.

Выражение `xs take n` возвращает первые `n` элементов списка `xs`. Если `n`  больше `xs.length`, возвращается весь список `xs`. Операция `xs drop n` возвращает все элементы списка `xs`, за исключением первых `n` элементов. Если `n` больше `xs.length`, возвращается пустой список.
```scala
val lst = List.range(1, 10)  // List[Int] = List(4, 5, 6, 7, 8, 9)
// удалил первые 3 элемента
lst.drop(3)  // List[Int] = List(4, 5, 6, 7, 8, 9)
// вернул первые 5 элементов
lst.take(5)  // List[Int] = List(1, 2, 3, 4, 5)
```

Произвольный выбор элемента поддерживается методом `.apply`, но эта операция менее востребована, чем подобная операция для массивов
```scala
val lst = List("a", "b", "c")
lst(1)  // b
```

Одной из причин того, что выбор произвольного элемента менее популярен для списков, чем для массивов, является то, что на выполнение кода `xs(n)` затрачивается время, пропорциональное величине значения индекса `n`. Фактически метод `.apply` определен сочетанием методов `.drop` и `.head`.

Метод `.flatten` получает список списков и линеаризует его в единый список
```scala
scala> List(List(3, 4), List(), List(4, 5)).flatten  // List[Int] = List(1, 2, 4, 5)
```

Объединение в пары и обратное разбиение
```scala
scala> "Python".indices.zip("Python").toList // List[(Int, Char)] = List((0,P), (1,y), (2,t), (3,h), (4,o), (5,n))
```
Здесь все элементы без пары отбрасываются!

```scala
scala> val lang1 = "Python"
scala> val lang2 = "Scala"
scala> lang1.zip(lang2) // IndexedSeq[(Char, Char)] = Vector((P,S), (y,c), (t,a), (h,l), (o,a))
```

Если нужно получить пары "элемент - индекс элемента", то лучше воспользоваться методом `.zipWithIndex`
```scala
scala> "Scala".zipWithIndex // IndexedSeq[(Char, Int)] = Vector((S,0), (c,1), (a,2), (l,3), (a,4))
```

Распаковать можно так
```scala
scala> val lang1 = "Python"
scala> val lang2 = "Scala"
scala> val (v1, v2) = lang1.zip(lang2).unzip
```

Преобразовать список в строку можно так
```scala
scala> List(1, 2, 3).mkString(":")  // 1:2:3
scala> List(1, 2, 3).mkString("[", ",", "]")  // [1,2,3]
```

Операция `.map` возвращает список, получившийся в результате применения функции к каждому элементу списка
```scala
scala> List("Python", "Scala", "Java").map(_.length)  // List[Int] = List(6, 5, 4)
scala> List("Python", "Scala", "Java").map(_.reverse.mkString)  // List[String] = List(nohtyP, alacS, avaJ)
```

Оператор `.flatMap` похож на `.map`, но в качестве правого операнда получает функцию, возвращающую список элементов. Он применяет функцию к каждому элементу списка и возвращает объединение всех результатов выполнения функции.
```scala
List.range(1, 5).flatMap {
  i => List.range(1, i).map(j => (i, j))
}
```

Например, отобрать все четные числа из коллекции можно так
```scala
scala> List.range(1, 5).filter(_ % 2 == 0)  // List(2, 4)
```

```scala
scala> List("Python", "Scala", "Java").filter(_.length == 4)  // List(Java)
```
В Python это выглядело бы так
```python
[lang for lang in ["Python", "Scala", "Java"] if len(lang) == 4]  # ["Java"]
```

Метод `.partition` похож на метод `.filter`, но возвращает пару списков. Один список содержит все элементы, для которых предикат вычисляется в `true`, а другой -- все элементы, для которых предикат вычисляется в `false`.
```scala
List.range(1, 5).partition(_ % 2 == 0)  // (List[Int], List[Int]) = (List(2, 4),List(1, 3) 
```

Метод `.find` также похож на метод `.filter`, но возвращает только первый элемент, удовлетворяющий условию заданного предиката, а не все такие элементы. 
```scala
List.range(1, 5).find(_ % 2 == 0)  // Some(2)
```
Операторы `.takeWhile` и `.dropWhile` также получают в качестве правого операнда предикат
```scala
List(1, 6, 4, 2, -1, 10).takeWhile(_ > 0)  // List[Int] = List(1, 6, 4, 2)
List("Python", "Scala", "Java").dropWhile(_.endsWith("n"))
```

Операция `.forall` возвращает `true`, если все элементы списка удовлетворяют условию предиката. А операция `.exists` возвращает `true`, если имеется элемент, удовлетворяющий условию предиката.
```scala
List.range(1, 5).forall(_ % 2 == 0)  // false
List(2, 6, 8).forall(_ % 2 == 0)  // true

List("Python", "Java").exists(_.length == 4) // true
```

У класса `List` есть объект-компаньон, содержащий несколько полезных методов.
```scala
List.range(1, 5)
List.range(9, 1, -3)
```

Метод `.fill` создает список, состоящий из нуля или более копий одного и того же элемента
```scala
List.fill(3)('a') // List('a', 'a', 'a')
```
В Python эту задачу можно решить так
```scala
["a"] * 3  # ["a", "a", "a"]
```
Объединить несколько списков можно так
```scala
List.concat(List(10, 20), List(30, 40))  // List(10, 20, 30, 40)
``` 
Совместная обработка нескольких списков выглядит так
```scala
List(10, 20).lazyZip(List(-1, -2)).map(_ * _)  // List[Int] = List(-10, -40)
// Первый заполнитель относится к первому списку, а второй - ко второму
List("Python", "Scala", "Java").lazyZip(List(6, 5, 4)).map(_.length == _)
```
