_Композиция_ означает, что один класс содержит ссылку на другой и использует класс, на который ссылается, в качестве вспомогательного средства для выполнения миссии. _Наследование_ представляет собой взаимоотношения родительского класса и его подкласса.
### Определение параметрических полей

Определение `contents` в качестве параметрического поля
```scala
class ArrayElement(
  val contents: Array[String]
) extends Element
```
NB! Если не указать `val`, то получится приватный параметр главного конструктора. То есть доступ к этому полю через экземпляр класса получить не удастся.

Обратите внимание на то, что параметр `contents` имеет префикс `val`. Это сокращенная форма записи, определяющая одновременно _параметр_ и _поле_ с одним и тем же именем. То есть класс `ArrayElements` теперь имеет поле `contents` (ему нельзя присвоить новое значение, потому что `val`), доступ к которому может быть получен за пределами класса. Поле инициализировано значением параметра. Похоже на то, будто бы класс был написан следующим образом
```scala
class ArrayElement(x123: Array[String]) extends Element {
  val contents: Array[String] = x123  // `contents` это публичное поле
}
```

Можно также поставить перед параметром класса префикс `var`, и тогда соответствующему полю можно будет переприсвоить значение. И наконец, подобным параметризованным полям, как и любым другим элементам класса, разрешено добавлять такие модификаторы, как `protected`, `private` или `override`. Пример
```scala
class Cat {
  val dangerous = false
}

class Tiger(
  override val dangerous: Boolean,
  private var age: Int
) extends Cat
```

Здесь `dangerous` и `age` это _параметрические поля_. Эта запись тоже что и 
```scala
class Tiger(
  param1: Boolean,
  param2: Int
) extends Cat {
  override val dangerous = param1
  private var age = param2
}
```

_Композиция_ и _наследование_ являются двумя способами определения нового класса в понятиях другого существующего класса. Если вы ориентируетесь преимущественно _на многократное использование кода_, то, как правило, _предпочтение_ нужно отдавать _композиции_, ==а не наследованию==. ==Проблемой хрупкости основного класса, вследствие которой можно ненароком сделать неработоспособными подклассы, внося изменения в родительский класс, страдает _только наследование_== [[Литература#^311838]]<c. 199>.
### Трейты

_Трейты_ (типажи) в Scala являются фундаментальными многократно используемыми блоками кода. _В трейте инкапсулируются определения тех методов и полей, которые затем могут многократно использоваться путем их подмешивания в классы_. В отличие от наследования классов, в котором каждый класс должен быть наследником только одного родительского класса, в класс может подмешиваться любое количество трейтов [[Литература#^311838]]<c. 218>.

Пример трейта
```scala
trait Employee {
  def getSummary: String = "Summary ..."
}
```

После того как трейт определен, он может быть _подмешан в класс_ с использованием ключевого слова `extends`, либо ключевого слова `with`. Программисты, работающие со Scala, подмешивают трейты, а не устраивают их наследование, поскольку подмешивание трейта имеет важное отличие от множественного наследования. 

Для подмешивания трейта можно использовать ключевое слово `extends`, в таком случае происходит подразумеваемое наследование родительского класса трейта. _Методы, унаследованные от трейта, могут использоваться точно так же, как и методы, унаследованные от родительского класса_.
```scala
class Person(
  uiid: Int,  // приватный параметр главного конструктра, так как нет val/var
  val name: String,  // публичный параметр-поле
  val age: Int,  // публичный параметр-поле
  val email: String  // публичный параметр-поле
) extends Employee
```
Здесь параметр `uiid` приватный (к нему нельзя получить доступ через экземпляр класса), а остальные параметры публичные и к тому же еще являются и полями -- к ним можно обращаться через экземпляр класса.
```scala
scala> val leor = new Person(
         uiid=888,
         name="Leor Finkelberg",
         age=37,
         email="leor.finkelberg@yandex.ru"
       )
scala> leor.getSummary  // Summary ... 
```
Через переменную `leor`, связанную с экземпляром класса `Person`, получаем доступ к методу-аксессору, определенному в трейте `Employee`.

Если нужно подмешать трейт в класс, который расширяет родительский класс явным образом, ключевое слово `extends` применяется для указания родительского класса, а для подмешивания трейта используется ключевое слово `with`.
```scala
class Animal  // просто класс без элементов

// Philosophical -- это трейт
class Frog extends Animal with Philosophical {
  override def toString = "green"
}
```

Можно подмешивать сразу несколько трейтов
```scala
class Animal

trait HasLegs

// Philosophical и HasLegs -- это трейты
class Frog extends Animal with Philosophical with HasLegs {
  override def toString = "green"
}
```

В трейтах могут, к примеру, объявляться поля и сохраняться состояние. Фактически в определении трейта можно делать то же самое, что и в определении класса, и синтаксис выглядит почти так же, но с двумя исключениями [[Литература#^311838]]<c. 221>:
- В трейте не может быть никаких присущих классу параметров (то есть параметров, передаваемых первичному конструктору класса),
- В классах вызовы `super` имеют _статическую_ привязку, а в трейтах -- _динамическую_. Если воспользоваться `super.toString`, вы точно будете знать, какая именно реализация метода будет вызвана. Но когда точно такой же код применяется в трейте, то вызываемая с помощью `super` реализация метода при определении трейта еще не установлена. Вызываемая реализация станет определяться заново при каждом подмешивании трейта в конкретный класс.

_Чаще всего трейты используются для автоматического добавления к классу методов в дополнение к тем методам, которые в нем уже имеются_. То есть трейты способны _обогатить скудный интерфейс_, превратив его в насыщенный [[Литература#^311838]]<c. 221>.

Пример
```scala
// Это обогащающий трейт
trait Rectangular {
  def topLeft: Point  // абстрактный метод-аксессор
  def topLeft: Point  // абстрактный метод-аксессор

  // конкретные методы
  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
}
```

Этот трейт можно подмешать в класс `Component`, чтобы получить все геометрические методы, предоставляемые трейтом `Rectangular`
```scala
abstract class Component extends Rectangular {
  // другие методы ...
}
```

Точно также трейт может подмешиваться в сам `Rectangle`
```scala
class Rectangle(val topLeft: Point, val bottomRight: Point) extends Rectangular {
  // другие методы
}
```

А еще трейты можно использовать для предоставления классам _наращиваемых изменений_ [[Литература#^311838]]<c. 226>.

Рекомендации по трейтам:
- Если поведение _не предназначено для многократного использования_, тогда создавайте _конкретный класс_, поскольку в нем вообще нет повторно используемого поведения.
- Если поведение может быть _использовано многократно независимо от классов_, создайте _трейт_.
- Если нужно получить наследство от класса в коде Java, воспользуйтесь _абстрактным классом_.
- Если планируется распространение программы в скомпилированном виде и ожидается, что сторонние группы разработчиков станут создавать классы, что-либо из нее наследующие, следует отдать предпочтение использованию _абстрактных классов_.
- Если не пришли к решению, то начните с создания трейта. Позже вы всегда сможете его изменить, а в целом использование трейта оставляет возможность применения большинства вариантов.